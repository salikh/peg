// Copyright 2019 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package // DO NOT EDIT. AUTOGENERATED
// Source grammar:
/*
Grammar <- Rule+ _

Rule <- _ Ident _ '<' '-' RHS EndOfLine?
RHS <- Terms ( _ '/' Terms ) *
Terms <- Term+
Term <- Parens / NegPred / Pred / Capture / CharClass / Literal / Ident / Special
Special <- _ < [*?.+] >
Parens <- _ '(' RHS _ ')'
NegPred <- _ '!' Term
Pred <- _ '&' Term
Capture <- _ '<' RHS _ '>'

Literal <- _ < '"' ( !'"' . ) * '"' > / _ < "'" ( !"'" . )* "'" >
Ident <- [ \t]* < [a-zA-Z_][a-zA-Z0-9_]* >
CharClass <- _ '[' < ('[:' [a-z]+ ':]' / ( !']' . )* ) > ']'

EndOfLine <- [ \t]* ( "\r\n" / "\r" / "\n")
_ <- ( [ \t\r\n] / '#' ( !"\n" .)* "\n"? )*

*/parser2

import (
	"fmt"
	"unicode"
	"unicode/utf8"

	log "github.com/golang/glog"
	"github.com/salikh/peg/parser"
)

type NodeStack []*parser.Node

type // result encapsulates one parse result.
result struct {
	Source string
	Memo   map[int]map[int]*parser.Node
	Level  int
	Tree   *parser.Node
	NodeStack
}

func (s *NodeStack) Push(n *parser.Node) {
	*s = append(*s, n)
}
func (s *NodeStack) Pop() *parser.Node {
	last := len(*s) - 1
	n := (*s)[last]
	*s = (*s)[:last]
	return n
}

func (r *result) TopNode() *parser.Node {
	last := len(r.NodeStack) - 1
	if last < 0 {
		log.Exitf("Internal error: no top node")
	}
	return r.NodeStack[last]
}
func (r *result) Attach(n *parser.Node) {
	if n.Text == "" && len(n.Children) == 0 && len(n.Annotations) == 0 && len(n.TreeAnnotations) == 0 {
		// Heuristic: do not attach the nodes without any useful annotations,
		// text or children.
		log.V(5).Infof("not attachign %s", n.Label)
		return
	}
	last := len(r.NodeStack) - 1
	if last < 0 {
		if r.Tree != nil {
			log.Exitf("Internal error: Attempting to attach root node twice")
		}
		r.Tree = n
		return
	}
	r.NodeStack[last].Children = append(r.NodeStack[last].Children, n)
}
func CaptureStartHandler(r *result, pos int) (int, error) {
	if r.TopNode() == nil {
		return 0, fmt.Errorf("internal error, cannot start capture without a node")
	}
	r.TopNode().Start = pos
	return 0, nil
}
func CaptureEndHandler(r *result, pos int) (int, error) {
	if r.TopNode() == nil {
		return 0, fmt.Errorf("internal error, cannot end capture without a node")
	}
	r.TopNode().Text = r.Source[r.TopNode().Start:pos]
	return 0, nil
}

func apply(r *result, pos int, h func(r *result, pos int) (int, error), hi int) (int, error) {
	r.Level++
	defer func() {
		r.Level--
	}()
	memo, ok := r.Memo[pos]
	if !ok {
		memo = make(map[int]*parser.Node)
		r.Memo[pos] = memo
	}
	n := memo[hi]
	if n != nil && n.Err == nil {
		r.Attach(n)
		return n.Len, nil
	}
	if n != nil && n.Err != nil {
		return n.Len, n.Err
	}
	n = &parser.Node{Label: labels[hi]}
	r.NodeStack.Push(n)
	w, err := h(r, pos)
	if err != nil {
		n := r.NodeStack.Pop()
		n.Len = w
		n.Err = err
		memo[hi] = n
		return n.Len, err
	}
	n = r.NodeStack.Pop()
	n.Len = w
	n.Pos = pos
	memo[hi] = n
	r.Attach(n)
	return w, nil
}
func Term_1_1(r *result, pos int) (int, error) {
	return apply(r, pos, ParensHandler, 6)
}
func Term_1(r *result, pos int) (int, error) {
	ww := 0
	var w int
	var err error
	w, err = Term_1_1(r, pos+ww)
	ww += w
	if err != nil {
		return ww, err
	}
	return ww, nil
}
func Term_2_1(r *result, pos int) (int, error) {
	return apply(r, pos, NegPredHandler, 7)
}
func Term_2(r *result, pos int) (int, error) {
	ww := 0
	var w int
	var err error
	w, err = Term_2_1(r, pos+ww)
	ww += w
	if err != nil {
		return ww, err
	}
	return ww, nil
}
func Term_3_1(r *result, pos int) (int, error) {
	return apply(r, pos, PredHandler, 8)
}
func Term_3(r *result, pos int) (int, error) {
	ww := 0
	var w int
	var err error
	w, err = Term_3_1(r, pos+ww)
	ww += w
	if err != nil {
		return ww, err
	}
	return ww, nil
}
func Term_4_1(r *result, pos int) (int, error) {
	return apply(r, pos, CaptureHandler, 9)
}
func Term_4(r *result, pos int) (int, error) {
	ww := 0
	var w int
	var err error
	w, err = Term_4_1(r, pos+ww)
	ww += w
	if err != nil {
		return ww, err
	}
	return ww, nil
}
func Term_5_1(r *result, pos int) (int, error) {
	return apply(r, pos, CharClassHandler, 12)
}
func Term_5(r *result, pos int) (int, error) {
	ww := 0
	var w int
	var err error
	w, err = Term_5_1(r, pos+ww)
	ww += w
	if err != nil {
		return ww, err
	}
	return ww, nil
}
func Term_6_1(r *result, pos int) (int, error) {
	return apply(r, pos, LiteralHandler, 10)
}
func Term_6(r *result, pos int) (int, error) {
	ww := 0
	var w int
	var err error
	w, err = Term_6_1(r, pos+ww)
	ww += w
	if err != nil {
		return ww, err
	}
	return ww, nil
}
func Term_7_1(r *result, pos int) (int, error) {
	return apply(r, pos, IdentHandler, 11)
}
func Term_7(r *result, pos int) (int, error) {
	ww := 0
	var w int
	var err error
	w, err = Term_7_1(r, pos+ww)
	ww += w
	if err != nil {
		return ww, err
	}
	return ww, nil
}
func Term_8_1(r *result, pos int) (int, error) {
	return apply(r, pos, SpecialHandler, 5)
}
func Term_8(r *result, pos int) (int, error) {
	ww := 0
	var w int
	var err error
	w, err = Term_8_1(r, pos+ww)
	ww += w
	if err != nil {
		return ww, err
	}
	return ww, nil
}
func TermHandler(r *result, pos int) (int, error) {
	w, err := Term_1(r, pos)
	if err != nil {
		w, err = Term_2(r, pos)
	}
	if err != nil {
		w, err = Term_3(r, pos)
	}
	if err != nil {
		w, err = Term_4(r, pos)
	}
	if err != nil {
		w, err = Term_5(r, pos)
	}
	if err != nil {
		w, err = Term_6(r, pos)
	}
	if err != nil {
		w, err = Term_7(r, pos)
	}
	if err != nil {
		w, err = Term_8(r, pos)
	}
	return w, err
}
func Ident_1_1_star(r *result, pos int) (int, error) {
	var charClassMap = map[rune]bool{' ': true, '\t': true}
	c, w := utf8.DecodeRuneInString(r.Source[pos:])
	if w == 0 {
		return 0, fmt.Errorf("expecting char, got EOF")
	}
	if c == utf8.RuneError {
		return w, fmt.Errorf("invalid utf8: %q", r.Source[pos:pos+w])
	}
	if !charClassMap[c] {
		return 0, fmt.Errorf("character %q does not match class [\t ]", c)
	}
	return w, nil
}
func Ident_1_1(r *result, pos int) (int, error) {
	ww := 0
	for w, err := Ident_1_1_star(r, pos); err == nil && w > 0; w, err = Ident_1_1_star(r, pos+ww) {
		ww += w
	}
	return ww, nil
}
func Ident_1_2_capture_1_1(r *result, pos int) (int, error) {
	var charClassMap = map[rune]bool{'_': true}
	var rangeTable = &unicode.RangeTable{R16: []unicode.Range16{unicode.Range16{Lo: 0x41, Hi: 0x5a, Stride: 1}, unicode.Range16{Lo: 0x61, Hi: 0x7a, Stride: 1}}}
	c, w := utf8.DecodeRuneInString(r.Source[pos:])
	if w == 0 {
		return 0, fmt.Errorf("expecting char, got EOF")
	}
	if c == utf8.RuneError {
		return w, fmt.Errorf("invalid utf8: %q", r.Source[pos:pos+w])
	}
	if !(charClassMap[c] || unicode.Is(rangeTable, c)) {
		return 0, fmt.Errorf("character %q does not match class [_A-Za-z]", c)
	}
	return w, nil
}
func Ident_1_2_capture_1_2_star(r *result, pos int) (int, error) {
	var charClassMap = map[rune]bool{'_': true}
	var rangeTable = &unicode.RangeTable{R16: []unicode.Range16{unicode.Range16{Lo: 0x30, Hi: 0x39, Stride: 1}, unicode.Range16{Lo: 0x41, Hi: 0x5a, Stride: 1}, unicode.Range16{Lo: 0x61, Hi: 0x7a, Stride: 1}}}
	c, w := utf8.DecodeRuneInString(r.Source[pos:])
	if w == 0 {
		return 0, fmt.Errorf("expecting char, got EOF")
	}
	if c == utf8.RuneError {
		return w, fmt.Errorf("invalid utf8: %q", r.Source[pos:pos+w])
	}
	if !(charClassMap[c] || unicode.Is(rangeTable, c)) {
		return 0, fmt.Errorf("character %q does not match class [_0-9A-Za-z]", c)
	}
	return w, nil
}
func Ident_1_2_capture_1_2(r *result, pos int) (int, error) {
	ww := 0
	for w, err := Ident_1_2_capture_1_2_star(r, pos); err == nil && w > 0; w, err = Ident_1_2_capture_1_2_star(r, pos+ww) {
		ww += w
	}
	return ww, nil
}
func Ident_1_2_capture_1(r *result, pos int) (int, error) {
	ww := 0
	var w int
	var err error
	w, err = Ident_1_2_capture_1_1(r, pos+ww)
	ww += w
	if err != nil {
		return ww, err
	}
	w, err = Ident_1_2_capture_1_2(r, pos+ww)
	ww += w
	if err != nil {
		return ww, err
	}
	return ww, nil
}
func Ident_1_2_capture(r *result, pos int) (int, error) {
	w, err := Ident_1_2_capture_1(r, pos)
	return w, err
}
func Ident_1_2(r *result, pos int) (int, error) {
	w, err := Ident_1_2_capture(r, pos)
	if err != nil {
		return w, err
	}
	r.TopNode().Start = pos
	r.TopNode().Text = r.Source[pos : pos+w]
	return w, nil
}
func Ident_1(r *result, pos int) (int, error) {
	ww := 0
	var w int
	var err error
	w, err = Ident_1_1(r, pos+ww)
	ww += w
	if err != nil {
		return ww, err
	}
	w, err = Ident_1_2(r, pos+ww)
	ww += w
	if err != nil {
		return ww, err
	}
	return ww, nil
}
func IdentHandler(r *result, pos int) (int, error) {
	w, err := Ident_1(r, pos)
	return w, err
}
func Pred_1_1(r *result, pos int) (int, error) {
	return apply(r, pos, _Handler, 14)
}
func Pred_1_2(r *result, pos int) (int, error) {
	const literal = "&"
	if len(r.Source)-pos < len(literal) {
		return 0, fmt.Errorf("expecting %q, got %q", literal, r.Source[pos:])
	}
	next := r.Source[pos : pos+len(literal)]
	if next != literal {
		return 0, fmt.Errorf("expecting %q, got %q", literal, next)
	}
	return len(literal), nil
}
func Pred_1_3(r *result, pos int) (int, error) {
	return apply(r, pos, TermHandler, 4)
}
func Pred_1(r *result, pos int) (int, error) {
	ww := 0
	var w int
	var err error
	w, err = Pred_1_1(r, pos+ww)
	ww += w
	if err != nil {
		return ww, err
	}
	w, err = Pred_1_2(r, pos+ww)
	ww += w
	if err != nil {
		return ww, err
	}
	w, err = Pred_1_3(r, pos+ww)
	ww += w
	if err != nil {
		return ww, err
	}
	return ww, nil
}
func PredHandler(r *result, pos int) (int, error) {
	w, err := Pred_1(r, pos)
	return w, err
}
func CharClass_1_1(r *result, pos int) (int, error) {
	return apply(r, pos, _Handler, 14)
}
func CharClass_1_2(r *result, pos int) (int, error) {
	const literal = "["
	if len(r.Source)-pos < len(literal) {
		return 0, fmt.Errorf("expecting %q, got %q", literal, r.Source[pos:])
	}
	next := r.Source[pos : pos+len(literal)]
	if next != literal {
		return 0, fmt.Errorf("expecting %q, got %q", literal, next)
	}
	return len(literal), nil
}
func CharClass_1_3_capture_1_1_paren_1_1(r *result, pos int) (int, error) {
	const literal = "[:"
	if len(r.Source)-pos < len(literal) {
		return 0, fmt.Errorf("expecting %q, got %q", literal, r.Source[pos:])
	}
	next := r.Source[pos : pos+len(literal)]
	if next != literal {
		return 0, fmt.Errorf("expecting %q, got %q", literal, next)
	}
	return len(literal), nil
}
func CharClass_1_3_capture_1_1_paren_1_2_plus(r *result, pos int) (int, error) {
	var rangeTable = &unicode.RangeTable{R16: []unicode.Range16{unicode.Range16{Lo: 0x61, Hi: 0x7a, Stride: 1}}}
	c, w := utf8.DecodeRuneInString(r.Source[pos:])
	if w == 0 {
		return 0, fmt.Errorf("expecting char, got EOF")
	}
	if c == utf8.RuneError {
		return w, fmt.Errorf("invalid utf8: %q", r.Source[pos:pos+w])
	}
	if !unicode.Is(rangeTable, c) {
		return 0, fmt.Errorf("character %q does not match class [a-z]", c)
	}
	return w, nil
}
func CharClass_1_3_capture_1_1_paren_1_2(r *result, pos int) (int, error) {
	w, err := CharClass_1_3_capture_1_1_paren_1_2_plus(r, pos)
	if err != nil {
		return 0, err
	}
	ww := w
	for w, err = CharClass_1_3_capture_1_1_paren_1_2_plus(r, pos+ww); err == nil && w > 0 && pos+ww < len(r.Source); w, err = CharClass_1_3_capture_1_1_paren_1_2_plus(r, pos+ww) {
		ww += w
	}
	return ww, nil
}
func CharClass_1_3_capture_1_1_paren_1_3(r *result, pos int) (int, error) {
	const literal = ":]"
	if len(r.Source)-pos < len(literal) {
		return 0, fmt.Errorf("expecting %q, got %q", literal, r.Source[pos:])
	}
	next := r.Source[pos : pos+len(literal)]
	if next != literal {
		return 0, fmt.Errorf("expecting %q, got %q", literal, next)
	}
	return len(literal), nil
}
func CharClass_1_3_capture_1_1_paren_1(r *result, pos int) (int, error) {
	ww := 0
	var w int
	var err error
	w, err = CharClass_1_3_capture_1_1_paren_1_1(r, pos+ww)
	ww += w
	if err != nil {
		return ww, err
	}
	w, err = CharClass_1_3_capture_1_1_paren_1_2(r, pos+ww)
	ww += w
	if err != nil {
		return ww, err
	}
	w, err = CharClass_1_3_capture_1_1_paren_1_3(r, pos+ww)
	ww += w
	if err != nil {
		return ww, err
	}
	return ww, nil
}
func CharClass_1_3_capture_1_1_paren_2_1_star_paren_1_1_neg(r *result, pos int) (int, error) {
	const literal = "]"
	if len(r.Source)-pos < len(literal) {
		return 0, fmt.Errorf("expecting %q, got %q", literal, r.Source[pos:])
	}
	next := r.Source[pos : pos+len(literal)]
	if next != literal {
		return 0, fmt.Errorf("expecting %q, got %q", literal, next)
	}
	return len(literal), nil
}
func CharClass_1_3_capture_1_1_paren_2_1_star_paren_1_1(r *result, pos int) (int, error) {
	const negative = true
	_, err := CharClass_1_3_capture_1_1_paren_2_1_star_paren_1_1_neg(r, pos)
	if negative == (err != nil) {
		return 0, nil
	}
	if err == nil {
		return 0, fmt.Errorf("negative predicate matched")
	}
	return 0, err
}
func CharClass_1_3_capture_1_1_paren_2_1_star_paren_1_2(r *result, pos int) (int, error) {
	if pos == len(r.Source) {
		return 0, fmt.Errorf("expected character, got EOF")
	}
	c, w := utf8.DecodeRuneInString(r.Source[pos:])
	if c == utf8.RuneError {
		return w, fmt.Errorf("invalid utf8: %q", r.Source[pos:pos+w])
	}
	return w, nil
}
func CharClass_1_3_capture_1_1_paren_2_1_star_paren_1(r *result, pos int) (int, error) {
	ww := 0
	var w int
	var err error
	w, err = CharClass_1_3_capture_1_1_paren_2_1_star_paren_1_1(r, pos+ww)
	ww += w
	if err != nil {
		return ww, err
	}
	w, err = CharClass_1_3_capture_1_1_paren_2_1_star_paren_1_2(r, pos+ww)
	ww += w
	if err != nil {
		return ww, err
	}
	return ww, nil
}
func CharClass_1_3_capture_1_1_paren_2_1_star(r *result, pos int) (int, error) {
	w, err := CharClass_1_3_capture_1_1_paren_2_1_star_paren_1(r, pos)
	return w, err
}
func CharClass_1_3_capture_1_1_paren_2_1(r *result, pos int) (int, error) {
	ww := 0
	for w, err := CharClass_1_3_capture_1_1_paren_2_1_star(r, pos); err == nil && w > 0; w, err = CharClass_1_3_capture_1_1_paren_2_1_star(r, pos+ww) {
		ww += w
	}
	return ww, nil
}
func CharClass_1_3_capture_1_1_paren_2(r *result, pos int) (int, error) {
	ww := 0
	var w int
	var err error
	w, err = CharClass_1_3_capture_1_1_paren_2_1(r, pos+ww)
	ww += w
	if err != nil {
		return ww, err
	}
	return ww, nil
}
func CharClass_1_3_capture_1_1(r *result, pos int) (int, error) {
	w, err := CharClass_1_3_capture_1_1_paren_1(r, pos)
	if err != nil {
		w, err = CharClass_1_3_capture_1_1_paren_2(r, pos)
	}
	return w, err
}
func CharClass_1_3_capture_1(r *result, pos int) (int, error) {
	ww := 0
	var w int
	var err error
	w, err = CharClass_1_3_capture_1_1(r, pos+ww)
	ww += w
	if err != nil {
		return ww, err
	}
	return ww, nil
}
func CharClass_1_3_capture(r *result, pos int) (int, error) {
	w, err := CharClass_1_3_capture_1(r, pos)
	return w, err
}
func CharClass_1_3(r *result, pos int) (int, error) {
	w, err := CharClass_1_3_capture(r, pos)
	if err != nil {
		return w, err
	}
	r.TopNode().Start = pos
	r.TopNode().Text = r.Source[pos : pos+w]
	return w, nil
}
func CharClass_1_4(r *result, pos int) (int, error) {
	const literal = "]"
	if len(r.Source)-pos < len(literal) {
		return 0, fmt.Errorf("expecting %q, got %q", literal, r.Source[pos:])
	}
	next := r.Source[pos : pos+len(literal)]
	if next != literal {
		return 0, fmt.Errorf("expecting %q, got %q", literal, next)
	}
	return len(literal), nil
}
func CharClass_1(r *result, pos int) (int, error) {
	ww := 0
	var w int
	var err error
	w, err = CharClass_1_1(r, pos+ww)
	ww += w
	if err != nil {
		return ww, err
	}
	w, err = CharClass_1_2(r, pos+ww)
	ww += w
	if err != nil {
		return ww, err
	}
	w, err = CharClass_1_3(r, pos+ww)
	ww += w
	if err != nil {
		return ww, err
	}
	w, err = CharClass_1_4(r, pos+ww)
	ww += w
	if err != nil {
		return ww, err
	}
	return ww, nil
}
func CharClassHandler(r *result, pos int) (int, error) {
	w, err := CharClass_1(r, pos)
	return w, err
}
func __1_1_star_paren_1_1(r *result, pos int) (int, error) {
	var charClassMap = map[rune]bool{' ': true, '\t': true, '\r': true, '\n': true}
	c, w := utf8.DecodeRuneInString(r.Source[pos:])
	if w == 0 {
		return 0, fmt.Errorf("expecting char, got EOF")
	}
	if c == utf8.RuneError {
		return w, fmt.Errorf("invalid utf8: %q", r.Source[pos:pos+w])
	}
	if !charClassMap[c] {
		return 0, fmt.Errorf("character %q does not match class [\t\n\r ]", c)
	}
	return w, nil
}
func __1_1_star_paren_1(r *result, pos int) (int, error) {
	ww := 0
	var w int
	var err error
	w, err = __1_1_star_paren_1_1(r, pos+ww)
	ww += w
	if err != nil {
		return ww, err
	}
	return ww, nil
}
func __1_1_star_paren_2_1(r *result, pos int) (int, error) {
	const literal = "#"
	if len(r.Source)-pos < len(literal) {
		return 0, fmt.Errorf("expecting %q, got %q", literal, r.Source[pos:])
	}
	next := r.Source[pos : pos+len(literal)]
	if next != literal {
		return 0, fmt.Errorf("expecting %q, got %q", literal, next)
	}
	return len(literal), nil
}
func __1_1_star_paren_2_2_star_paren_1_1_neg(r *result, pos int) (int, error) {
	const literal = "\n"
	if len(r.Source)-pos < len(literal) {
		return 0, fmt.Errorf("expecting %q, got %q", literal, r.Source[pos:])
	}
	next := r.Source[pos : pos+len(literal)]
	if next != literal {
		return 0, fmt.Errorf("expecting %q, got %q", literal, next)
	}
	return len(literal), nil
}
func __1_1_star_paren_2_2_star_paren_1_1(r *result, pos int) (int, error) {
	const negative = true
	_, err := __1_1_star_paren_2_2_star_paren_1_1_neg(r, pos)
	if negative == (err != nil) {
		return 0, nil
	}
	if err == nil {
		return 0, fmt.Errorf("negative predicate matched")
	}
	return 0, err
}
func __1_1_star_paren_2_2_star_paren_1_2(r *result, pos int) (int, error) {
	if pos == len(r.Source) {
		return 0, fmt.Errorf("expected character, got EOF")
	}
	c, w := utf8.DecodeRuneInString(r.Source[pos:])
	if c == utf8.RuneError {
		return w, fmt.Errorf("invalid utf8: %q", r.Source[pos:pos+w])
	}
	return w, nil
}
func __1_1_star_paren_2_2_star_paren_1(r *result, pos int) (int, error) {
	ww := 0
	var w int
	var err error
	w, err = __1_1_star_paren_2_2_star_paren_1_1(r, pos+ww)
	ww += w
	if err != nil {
		return ww, err
	}
	w, err = __1_1_star_paren_2_2_star_paren_1_2(r, pos+ww)
	ww += w
	if err != nil {
		return ww, err
	}
	return ww, nil
}
func __1_1_star_paren_2_2_star(r *result, pos int) (int, error) {
	w, err := __1_1_star_paren_2_2_star_paren_1(r, pos)
	return w, err
}
func __1_1_star_paren_2_2(r *result, pos int) (int, error) {
	ww := 0
	for w, err := __1_1_star_paren_2_2_star(r, pos); err == nil && w > 0; w, err = __1_1_star_paren_2_2_star(r, pos+ww) {
		ww += w
	}
	return ww, nil
}
func __1_1_star_paren_2_3_question(r *result, pos int) (int, error) {
	const literal = "\n"
	if len(r.Source)-pos < len(literal) {
		return 0, fmt.Errorf("expecting %q, got %q", literal, r.Source[pos:])
	}
	next := r.Source[pos : pos+len(literal)]
	if next != literal {
		return 0, fmt.Errorf("expecting %q, got %q", literal, next)
	}
	return len(literal), nil
}
func __1_1_star_paren_2_3(r *result, pos int) (int, error) {
	w, err := __1_1_star_paren_2_3_question(r, pos)
	if err != nil {
		return 0, nil
	}
	return w, nil
}
func __1_1_star_paren_2(r *result, pos int) (int, error) {
	ww := 0
	var w int
	var err error
	w, err = __1_1_star_paren_2_1(r, pos+ww)
	ww += w
	if err != nil {
		return ww, err
	}
	w, err = __1_1_star_paren_2_2(r, pos+ww)
	ww += w
	if err != nil {
		return ww, err
	}
	w, err = __1_1_star_paren_2_3(r, pos+ww)
	ww += w
	if err != nil {
		return ww, err
	}
	return ww, nil
}
func __1_1_star(r *result, pos int) (int, error) {
	w, err := __1_1_star_paren_1(r, pos)
	if err != nil {
		w, err = __1_1_star_paren_2(r, pos)
	}
	return w, err
}
func __1_1(r *result, pos int) (int, error) {
	ww := 0
	for w, err := __1_1_star(r, pos); err == nil && w > 0; w, err = __1_1_star(r, pos+ww) {
		ww += w
	}
	return ww, nil
}
func __1(r *result, pos int) (int, error) {
	ww := 0
	var w int
	var err error
	w, err = __1_1(r, pos+ww)
	ww += w
	if err != nil {
		return ww, err
	}
	return ww, nil
}
func _Handler(r *result, pos int) (int, error) {
	w, err := __1(r, pos)
	return w, err
}
func Terms_1_1_plus(r *result, pos int) (int, error) {
	return apply(r, pos, TermHandler, 4)
}
func Terms_1_1(r *result, pos int) (int, error) {
	w, err := Terms_1_1_plus(r, pos)
	if err != nil {
		return 0, err
	}
	ww := w
	for w, err = Terms_1_1_plus(r, pos+ww); err == nil && w > 0 && pos+ww < len(r.Source); w, err = Terms_1_1_plus(r, pos+ww) {
		ww += w
	}
	return ww, nil
}
func Terms_1(r *result, pos int) (int, error) {
	ww := 0
	var w int
	var err error
	w, err = Terms_1_1(r, pos+ww)
	ww += w
	if err != nil {
		return ww, err
	}
	return ww, nil
}
func TermsHandler(r *result, pos int) (int, error) {
	w, err := Terms_1(r, pos)
	return w, err
}
func Special_1_1(r *result, pos int) (int, error) {
	return apply(r, pos, _Handler, 14)
}
func Special_1_2_capture_1_1(r *result, pos int) (int, error) {
	var charClassMap = map[rune]bool{'*': true, '?': true, '.': true, '+': true}
	c, w := utf8.DecodeRuneInString(r.Source[pos:])
	if w == 0 {
		return 0, fmt.Errorf("expecting char, got EOF")
	}
	if c == utf8.RuneError {
		return w, fmt.Errorf("invalid utf8: %q", r.Source[pos:pos+w])
	}
	if !charClassMap[c] {
		return 0, fmt.Errorf("character %q does not match class [*+.?]", c)
	}
	return w, nil
}
func Special_1_2_capture_1(r *result, pos int) (int, error) {
	ww := 0
	var w int
	var err error
	w, err = Special_1_2_capture_1_1(r, pos+ww)
	ww += w
	if err != nil {
		return ww, err
	}
	return ww, nil
}
func Special_1_2_capture(r *result, pos int) (int, error) {
	w, err := Special_1_2_capture_1(r, pos)
	return w, err
}
func Special_1_2(r *result, pos int) (int, error) {
	w, err := Special_1_2_capture(r, pos)
	if err != nil {
		return w, err
	}
	r.TopNode().Start = pos
	r.TopNode().Text = r.Source[pos : pos+w]
	return w, nil
}
func Special_1(r *result, pos int) (int, error) {
	ww := 0
	var w int
	var err error
	w, err = Special_1_1(r, pos+ww)
	ww += w
	if err != nil {
		return ww, err
	}
	w, err = Special_1_2(r, pos+ww)
	ww += w
	if err != nil {
		return ww, err
	}
	return ww, nil
}
func SpecialHandler(r *result, pos int) (int, error) {
	w, err := Special_1(r, pos)
	return w, err
}
func NegPred_1_1(r *result, pos int) (int, error) {
	return apply(r, pos, _Handler, 14)
}
func NegPred_1_2(r *result, pos int) (int, error) {
	const literal = "!"
	if len(r.Source)-pos < len(literal) {
		return 0, fmt.Errorf("expecting %q, got %q", literal, r.Source[pos:])
	}
	next := r.Source[pos : pos+len(literal)]
	if next != literal {
		return 0, fmt.Errorf("expecting %q, got %q", literal, next)
	}
	return len(literal), nil
}
func NegPred_1_3(r *result, pos int) (int, error) {
	return apply(r, pos, TermHandler, 4)
}
func NegPred_1(r *result, pos int) (int, error) {
	ww := 0
	var w int
	var err error
	w, err = NegPred_1_1(r, pos+ww)
	ww += w
	if err != nil {
		return ww, err
	}
	w, err = NegPred_1_2(r, pos+ww)
	ww += w
	if err != nil {
		return ww, err
	}
	w, err = NegPred_1_3(r, pos+ww)
	ww += w
	if err != nil {
		return ww, err
	}
	return ww, nil
}
func NegPredHandler(r *result, pos int) (int, error) {
	w, err := NegPred_1(r, pos)
	return w, err
}
func Capture_1_1(r *result, pos int) (int, error) {
	return apply(r, pos, _Handler, 14)
}
func Capture_1_2(r *result, pos int) (int, error) {
	const literal = "<"
	if len(r.Source)-pos < len(literal) {
		return 0, fmt.Errorf("expecting %q, got %q", literal, r.Source[pos:])
	}
	next := r.Source[pos : pos+len(literal)]
	if next != literal {
		return 0, fmt.Errorf("expecting %q, got %q", literal, next)
	}
	return len(literal), nil
}
func Capture_1_3(r *result, pos int) (int, error) {
	return apply(r, pos, RHSHandler, 2)
}
func Capture_1_4(r *result, pos int) (int, error) {
	return apply(r, pos, _Handler, 14)
}
func Capture_1_5(r *result, pos int) (int, error) {
	const literal = ">"
	if len(r.Source)-pos < len(literal) {
		return 0, fmt.Errorf("expecting %q, got %q", literal, r.Source[pos:])
	}
	next := r.Source[pos : pos+len(literal)]
	if next != literal {
		return 0, fmt.Errorf("expecting %q, got %q", literal, next)
	}
	return len(literal), nil
}
func Capture_1(r *result, pos int) (int, error) {
	ww := 0
	var w int
	var err error
	w, err = Capture_1_1(r, pos+ww)
	ww += w
	if err != nil {
		return ww, err
	}
	w, err = Capture_1_2(r, pos+ww)
	ww += w
	if err != nil {
		return ww, err
	}
	w, err = Capture_1_3(r, pos+ww)
	ww += w
	if err != nil {
		return ww, err
	}
	w, err = Capture_1_4(r, pos+ww)
	ww += w
	if err != nil {
		return ww, err
	}
	w, err = Capture_1_5(r, pos+ww)
	ww += w
	if err != nil {
		return ww, err
	}
	return ww, nil
}
func CaptureHandler(r *result, pos int) (int, error) {
	w, err := Capture_1(r, pos)
	return w, err
}
func Grammar_1_1_plus(r *result, pos int) (int, error) {
	return apply(r, pos, RuleHandler, 1)
}
func Grammar_1_1(r *result, pos int) (int, error) {
	w, err := Grammar_1_1_plus(r, pos)
	if err != nil {
		return 0, err
	}
	ww := w
	for w, err = Grammar_1_1_plus(r, pos+ww); err == nil && w > 0 && pos+ww < len(r.Source); w, err = Grammar_1_1_plus(r, pos+ww) {
		ww += w
	}
	return ww, nil
}
func Grammar_1_2(r *result, pos int) (int, error) {
	return apply(r, pos, _Handler, 14)
}
func Grammar_1(r *result, pos int) (int, error) {
	ww := 0
	var w int
	var err error
	w, err = Grammar_1_1(r, pos+ww)
	ww += w
	if err != nil {
		return ww, err
	}
	w, err = Grammar_1_2(r, pos+ww)
	ww += w
	if err != nil {
		return ww, err
	}
	return ww, nil
}
func GrammarHandler(r *result, pos int) (int, error) {
	w, err := Grammar_1(r, pos)
	return w, err
}
func Rule_1_1(r *result, pos int) (int, error) {
	return apply(r, pos, _Handler, 14)
}
func Rule_1_2(r *result, pos int) (int, error) {
	return apply(r, pos, IdentHandler, 11)
}
func Rule_1_3(r *result, pos int) (int, error) {
	return apply(r, pos, _Handler, 14)
}
func Rule_1_4(r *result, pos int) (int, error) {
	const literal = "<"
	if len(r.Source)-pos < len(literal) {
		return 0, fmt.Errorf("expecting %q, got %q", literal, r.Source[pos:])
	}
	next := r.Source[pos : pos+len(literal)]
	if next != literal {
		return 0, fmt.Errorf("expecting %q, got %q", literal, next)
	}
	return len(literal), nil
}
func Rule_1_5(r *result, pos int) (int, error) {
	const literal = "-"
	if len(r.Source)-pos < len(literal) {
		return 0, fmt.Errorf("expecting %q, got %q", literal, r.Source[pos:])
	}
	next := r.Source[pos : pos+len(literal)]
	if next != literal {
		return 0, fmt.Errorf("expecting %q, got %q", literal, next)
	}
	return len(literal), nil
}
func Rule_1_6(r *result, pos int) (int, error) {
	return apply(r, pos, RHSHandler, 2)
}
func Rule_1_7_question(r *result, pos int) (int, error) {
	return apply(r, pos, EndOfLineHandler, 13)
}
func Rule_1_7(r *result, pos int) (int, error) {
	w, err := Rule_1_7_question(r, pos)
	if err != nil {
		return 0, nil
	}
	return w, nil
}
func Rule_1(r *result, pos int) (int, error) {
	ww := 0
	var w int
	var err error
	w, err = Rule_1_1(r, pos+ww)
	ww += w
	if err != nil {
		return ww, err
	}
	w, err = Rule_1_2(r, pos+ww)
	ww += w
	if err != nil {
		return ww, err
	}
	w, err = Rule_1_3(r, pos+ww)
	ww += w
	if err != nil {
		return ww, err
	}
	w, err = Rule_1_4(r, pos+ww)
	ww += w
	if err != nil {
		return ww, err
	}
	w, err = Rule_1_5(r, pos+ww)
	ww += w
	if err != nil {
		return ww, err
	}
	w, err = Rule_1_6(r, pos+ww)
	ww += w
	if err != nil {
		return ww, err
	}
	w, err = Rule_1_7(r, pos+ww)
	ww += w
	if err != nil {
		return ww, err
	}
	return ww, nil
}
func RuleHandler(r *result, pos int) (int, error) {
	w, err := Rule_1(r, pos)
	return w, err
}
func Literal_1_1(r *result, pos int) (int, error) {
	return apply(r, pos, _Handler, 14)
}
func Literal_1_2_capture_1_1(r *result, pos int) (int, error) {
	const literal = "\""
	if len(r.Source)-pos < len(literal) {
		return 0, fmt.Errorf("expecting %q, got %q", literal, r.Source[pos:])
	}
	next := r.Source[pos : pos+len(literal)]
	if next != literal {
		return 0, fmt.Errorf("expecting %q, got %q", literal, next)
	}
	return len(literal), nil
}
func Literal_1_2_capture_1_2_star_paren_1_1_neg(r *result, pos int) (int, error) {
	const literal = "\""
	if len(r.Source)-pos < len(literal) {
		return 0, fmt.Errorf("expecting %q, got %q", literal, r.Source[pos:])
	}
	next := r.Source[pos : pos+len(literal)]
	if next != literal {
		return 0, fmt.Errorf("expecting %q, got %q", literal, next)
	}
	return len(literal), nil
}
func Literal_1_2_capture_1_2_star_paren_1_1(r *result, pos int) (int, error) {
	const negative = true
	_, err := Literal_1_2_capture_1_2_star_paren_1_1_neg(r, pos)
	if negative == (err != nil) {
		return 0, nil
	}
	if err == nil {
		return 0, fmt.Errorf("negative predicate matched")
	}
	return 0, err
}
func Literal_1_2_capture_1_2_star_paren_1_2(r *result, pos int) (int, error) {
	if pos == len(r.Source) {
		return 0, fmt.Errorf("expected character, got EOF")
	}
	c, w := utf8.DecodeRuneInString(r.Source[pos:])
	if c == utf8.RuneError {
		return w, fmt.Errorf("invalid utf8: %q", r.Source[pos:pos+w])
	}
	return w, nil
}
func Literal_1_2_capture_1_2_star_paren_1(r *result, pos int) (int, error) {
	ww := 0
	var w int
	var err error
	w, err = Literal_1_2_capture_1_2_star_paren_1_1(r, pos+ww)
	ww += w
	if err != nil {
		return ww, err
	}
	w, err = Literal_1_2_capture_1_2_star_paren_1_2(r, pos+ww)
	ww += w
	if err != nil {
		return ww, err
	}
	return ww, nil
}
func Literal_1_2_capture_1_2_star(r *result, pos int) (int, error) {
	w, err := Literal_1_2_capture_1_2_star_paren_1(r, pos)
	return w, err
}
func Literal_1_2_capture_1_2(r *result, pos int) (int, error) {
	ww := 0
	for w, err := Literal_1_2_capture_1_2_star(r, pos); err == nil && w > 0; w, err = Literal_1_2_capture_1_2_star(r, pos+ww) {
		ww += w
	}
	return ww, nil
}
func Literal_1_2_capture_1_3(r *result, pos int) (int, error) {
	const literal = "\""
	if len(r.Source)-pos < len(literal) {
		return 0, fmt.Errorf("expecting %q, got %q", literal, r.Source[pos:])
	}
	next := r.Source[pos : pos+len(literal)]
	if next != literal {
		return 0, fmt.Errorf("expecting %q, got %q", literal, next)
	}
	return len(literal), nil
}
func Literal_1_2_capture_1(r *result, pos int) (int, error) {
	ww := 0
	var w int
	var err error
	w, err = Literal_1_2_capture_1_1(r, pos+ww)
	ww += w
	if err != nil {
		return ww, err
	}
	w, err = Literal_1_2_capture_1_2(r, pos+ww)
	ww += w
	if err != nil {
		return ww, err
	}
	w, err = Literal_1_2_capture_1_3(r, pos+ww)
	ww += w
	if err != nil {
		return ww, err
	}
	return ww, nil
}
func Literal_1_2_capture(r *result, pos int) (int, error) {
	w, err := Literal_1_2_capture_1(r, pos)
	return w, err
}
func Literal_1_2(r *result, pos int) (int, error) {
	w, err := Literal_1_2_capture(r, pos)
	if err != nil {
		return w, err
	}
	r.TopNode().Start = pos
	r.TopNode().Text = r.Source[pos : pos+w]
	return w, nil
}
func Literal_1(r *result, pos int) (int, error) {
	ww := 0
	var w int
	var err error
	w, err = Literal_1_1(r, pos+ww)
	ww += w
	if err != nil {
		return ww, err
	}
	w, err = Literal_1_2(r, pos+ww)
	ww += w
	if err != nil {
		return ww, err
	}
	return ww, nil
}
func Literal_2_1(r *result, pos int) (int, error) {
	return apply(r, pos, _Handler, 14)
}
func Literal_2_2_capture_1_1(r *result, pos int) (int, error) {
	const literal = "'"
	if len(r.Source)-pos < len(literal) {
		return 0, fmt.Errorf("expecting %q, got %q", literal, r.Source[pos:])
	}
	next := r.Source[pos : pos+len(literal)]
	if next != literal {
		return 0, fmt.Errorf("expecting %q, got %q", literal, next)
	}
	return len(literal), nil
}
func Literal_2_2_capture_1_2_star_paren_1_1_neg(r *result, pos int) (int, error) {
	const literal = "'"
	if len(r.Source)-pos < len(literal) {
		return 0, fmt.Errorf("expecting %q, got %q", literal, r.Source[pos:])
	}
	next := r.Source[pos : pos+len(literal)]
	if next != literal {
		return 0, fmt.Errorf("expecting %q, got %q", literal, next)
	}
	return len(literal), nil
}
func Literal_2_2_capture_1_2_star_paren_1_1(r *result, pos int) (int, error) {
	const negative = true
	_, err := Literal_2_2_capture_1_2_star_paren_1_1_neg(r, pos)
	if negative == (err != nil) {
		return 0, nil
	}
	if err == nil {
		return 0, fmt.Errorf("negative predicate matched")
	}
	return 0, err
}
func Literal_2_2_capture_1_2_star_paren_1_2(r *result, pos int) (int, error) {
	if pos == len(r.Source) {
		return 0, fmt.Errorf("expected character, got EOF")
	}
	c, w := utf8.DecodeRuneInString(r.Source[pos:])
	if c == utf8.RuneError {
		return w, fmt.Errorf("invalid utf8: %q", r.Source[pos:pos+w])
	}
	return w, nil
}
func Literal_2_2_capture_1_2_star_paren_1(r *result, pos int) (int, error) {
	ww := 0
	var w int
	var err error
	w, err = Literal_2_2_capture_1_2_star_paren_1_1(r, pos+ww)
	ww += w
	if err != nil {
		return ww, err
	}
	w, err = Literal_2_2_capture_1_2_star_paren_1_2(r, pos+ww)
	ww += w
	if err != nil {
		return ww, err
	}
	return ww, nil
}
func Literal_2_2_capture_1_2_star(r *result, pos int) (int, error) {
	w, err := Literal_2_2_capture_1_2_star_paren_1(r, pos)
	return w, err
}
func Literal_2_2_capture_1_2(r *result, pos int) (int, error) {
	ww := 0
	for w, err := Literal_2_2_capture_1_2_star(r, pos); err == nil && w > 0; w, err = Literal_2_2_capture_1_2_star(r, pos+ww) {
		ww += w
	}
	return ww, nil
}
func Literal_2_2_capture_1_3(r *result, pos int) (int, error) {
	const literal = "'"
	if len(r.Source)-pos < len(literal) {
		return 0, fmt.Errorf("expecting %q, got %q", literal, r.Source[pos:])
	}
	next := r.Source[pos : pos+len(literal)]
	if next != literal {
		return 0, fmt.Errorf("expecting %q, got %q", literal, next)
	}
	return len(literal), nil
}
func Literal_2_2_capture_1(r *result, pos int) (int, error) {
	ww := 0
	var w int
	var err error
	w, err = Literal_2_2_capture_1_1(r, pos+ww)
	ww += w
	if err != nil {
		return ww, err
	}
	w, err = Literal_2_2_capture_1_2(r, pos+ww)
	ww += w
	if err != nil {
		return ww, err
	}
	w, err = Literal_2_2_capture_1_3(r, pos+ww)
	ww += w
	if err != nil {
		return ww, err
	}
	return ww, nil
}
func Literal_2_2_capture(r *result, pos int) (int, error) {
	w, err := Literal_2_2_capture_1(r, pos)
	return w, err
}
func Literal_2_2(r *result, pos int) (int, error) {
	w, err := Literal_2_2_capture(r, pos)
	if err != nil {
		return w, err
	}
	r.TopNode().Start = pos
	r.TopNode().Text = r.Source[pos : pos+w]
	return w, nil
}
func Literal_2(r *result, pos int) (int, error) {
	ww := 0
	var w int
	var err error
	w, err = Literal_2_1(r, pos+ww)
	ww += w
	if err != nil {
		return ww, err
	}
	w, err = Literal_2_2(r, pos+ww)
	ww += w
	if err != nil {
		return ww, err
	}
	return ww, nil
}
func LiteralHandler(r *result, pos int) (int, error) {
	w, err := Literal_1(r, pos)
	if err != nil {
		w, err = Literal_2(r, pos)
	}
	return w, err
}
func EndOfLine_1_1_star(r *result, pos int) (int, error) {
	var charClassMap = map[rune]bool{' ': true, '\t': true}
	c, w := utf8.DecodeRuneInString(r.Source[pos:])
	if w == 0 {
		return 0, fmt.Errorf("expecting char, got EOF")
	}
	if c == utf8.RuneError {
		return w, fmt.Errorf("invalid utf8: %q", r.Source[pos:pos+w])
	}
	if !charClassMap[c] {
		return 0, fmt.Errorf("character %q does not match class [\t ]", c)
	}
	return w, nil
}
func EndOfLine_1_1(r *result, pos int) (int, error) {
	ww := 0
	for w, err := EndOfLine_1_1_star(r, pos); err == nil && w > 0; w, err = EndOfLine_1_1_star(r, pos+ww) {
		ww += w
	}
	return ww, nil
}
func EndOfLine_1_2_paren_1_1(r *result, pos int) (int, error) {
	const literal = "\r\n"
	if len(r.Source)-pos < len(literal) {
		return 0, fmt.Errorf("expecting %q, got %q", literal, r.Source[pos:])
	}
	next := r.Source[pos : pos+len(literal)]
	if next != literal {
		return 0, fmt.Errorf("expecting %q, got %q", literal, next)
	}
	return len(literal), nil
}
func EndOfLine_1_2_paren_1(r *result, pos int) (int, error) {
	ww := 0
	var w int
	var err error
	w, err = EndOfLine_1_2_paren_1_1(r, pos+ww)
	ww += w
	if err != nil {
		return ww, err
	}
	return ww, nil
}
func EndOfLine_1_2_paren_2_1(r *result, pos int) (int, error) {
	const literal = "\r"
	if len(r.Source)-pos < len(literal) {
		return 0, fmt.Errorf("expecting %q, got %q", literal, r.Source[pos:])
	}
	next := r.Source[pos : pos+len(literal)]
	if next != literal {
		return 0, fmt.Errorf("expecting %q, got %q", literal, next)
	}
	return len(literal), nil
}
func EndOfLine_1_2_paren_2(r *result, pos int) (int, error) {
	ww := 0
	var w int
	var err error
	w, err = EndOfLine_1_2_paren_2_1(r, pos+ww)
	ww += w
	if err != nil {
		return ww, err
	}
	return ww, nil
}
func EndOfLine_1_2_paren_3_1(r *result, pos int) (int, error) {
	const literal = "\n"
	if len(r.Source)-pos < len(literal) {
		return 0, fmt.Errorf("expecting %q, got %q", literal, r.Source[pos:])
	}
	next := r.Source[pos : pos+len(literal)]
	if next != literal {
		return 0, fmt.Errorf("expecting %q, got %q", literal, next)
	}
	return len(literal), nil
}
func EndOfLine_1_2_paren_3(r *result, pos int) (int, error) {
	ww := 0
	var w int
	var err error
	w, err = EndOfLine_1_2_paren_3_1(r, pos+ww)
	ww += w
	if err != nil {
		return ww, err
	}
	return ww, nil
}
func EndOfLine_1_2(r *result, pos int) (int, error) {
	w, err := EndOfLine_1_2_paren_1(r, pos)
	if err != nil {
		w, err = EndOfLine_1_2_paren_2(r, pos)
	}
	if err != nil {
		w, err = EndOfLine_1_2_paren_3(r, pos)
	}
	return w, err
}
func EndOfLine_1(r *result, pos int) (int, error) {
	ww := 0
	var w int
	var err error
	w, err = EndOfLine_1_1(r, pos+ww)
	ww += w
	if err != nil {
		return ww, err
	}
	w, err = EndOfLine_1_2(r, pos+ww)
	ww += w
	if err != nil {
		return ww, err
	}
	return ww, nil
}
func EndOfLineHandler(r *result, pos int) (int, error) {
	w, err := EndOfLine_1(r, pos)
	return w, err
}
func RHS_1_1(r *result, pos int) (int, error) {
	return apply(r, pos, TermsHandler, 3)
}
func RHS_1_2_star_paren_1_1(r *result, pos int) (int, error) {
	return apply(r, pos, _Handler, 14)
}
func RHS_1_2_star_paren_1_2(r *result, pos int) (int, error) {
	const literal = "/"
	if len(r.Source)-pos < len(literal) {
		return 0, fmt.Errorf("expecting %q, got %q", literal, r.Source[pos:])
	}
	next := r.Source[pos : pos+len(literal)]
	if next != literal {
		return 0, fmt.Errorf("expecting %q, got %q", literal, next)
	}
	return len(literal), nil
}
func RHS_1_2_star_paren_1_3(r *result, pos int) (int, error) {
	return apply(r, pos, TermsHandler, 3)
}
func RHS_1_2_star_paren_1(r *result, pos int) (int, error) {
	ww := 0
	var w int
	var err error
	w, err = RHS_1_2_star_paren_1_1(r, pos+ww)
	ww += w
	if err != nil {
		return ww, err
	}
	w, err = RHS_1_2_star_paren_1_2(r, pos+ww)
	ww += w
	if err != nil {
		return ww, err
	}
	w, err = RHS_1_2_star_paren_1_3(r, pos+ww)
	ww += w
	if err != nil {
		return ww, err
	}
	return ww, nil
}
func RHS_1_2_star(r *result, pos int) (int, error) {
	w, err := RHS_1_2_star_paren_1(r, pos)
	return w, err
}
func RHS_1_2(r *result, pos int) (int, error) {
	ww := 0
	for w, err := RHS_1_2_star(r, pos); err == nil && w > 0; w, err = RHS_1_2_star(r, pos+ww) {
		ww += w
	}
	return ww, nil
}
func RHS_1(r *result, pos int) (int, error) {
	ww := 0
	var w int
	var err error
	w, err = RHS_1_1(r, pos+ww)
	ww += w
	if err != nil {
		return ww, err
	}
	w, err = RHS_1_2(r, pos+ww)
	ww += w
	if err != nil {
		return ww, err
	}
	return ww, nil
}
func RHSHandler(r *result, pos int) (int, error) {
	w, err := RHS_1(r, pos)
	return w, err
}
func Parens_1_1(r *result, pos int) (int, error) {
	return apply(r, pos, _Handler, 14)
}
func Parens_1_2(r *result, pos int) (int, error) {
	const literal = "("
	if len(r.Source)-pos < len(literal) {
		return 0, fmt.Errorf("expecting %q, got %q", literal, r.Source[pos:])
	}
	next := r.Source[pos : pos+len(literal)]
	if next != literal {
		return 0, fmt.Errorf("expecting %q, got %q", literal, next)
	}
	return len(literal), nil
}
func Parens_1_3(r *result, pos int) (int, error) {
	return apply(r, pos, RHSHandler, 2)
}
func Parens_1_4(r *result, pos int) (int, error) {
	return apply(r, pos, _Handler, 14)
}
func Parens_1_5(r *result, pos int) (int, error) {
	const literal = ")"
	if len(r.Source)-pos < len(literal) {
		return 0, fmt.Errorf("expecting %q, got %q", literal, r.Source[pos:])
	}
	next := r.Source[pos : pos+len(literal)]
	if next != literal {
		return 0, fmt.Errorf("expecting %q, got %q", literal, next)
	}
	return len(literal), nil
}
func Parens_1(r *result, pos int) (int, error) {
	ww := 0
	var w int
	var err error
	w, err = Parens_1_1(r, pos+ww)
	ww += w
	if err != nil {
		return ww, err
	}
	w, err = Parens_1_2(r, pos+ww)
	ww += w
	if err != nil {
		return ww, err
	}
	w, err = Parens_1_3(r, pos+ww)
	ww += w
	if err != nil {
		return ww, err
	}
	w, err = Parens_1_4(r, pos+ww)
	ww += w
	if err != nil {
		return ww, err
	}
	w, err = Parens_1_5(r, pos+ww)
	ww += w
	if err != nil {
		return ww, err
	}
	return ww, nil
}
func ParensHandler(r *result, pos int) (int, error) {
	w, err := Parens_1(r, pos)
	return w, err
}

var labels = []string{"Grammar", "Rule", "RHS", "Terms", "Term", "Special", "Parens", "NegPred", "Pred", "Capture", "Literal", "Ident", "CharClass", "EndOfLine", "_"}

func parse(source string) (*result, error) {
	r := &result{Source: source, Memo: make(map[int]map[int]*parser.Node), NodeStack: make([]*parser.Node, 0, 10)}
	w, err := apply(r, 0, GrammarHandler, 0)
	if err != nil {
		return r, err
	}
	if w != len(source) {
		return r, fmt.Errorf("some characters remain unconsumed: %q", source[w:])
	}
	return r, nil
}
